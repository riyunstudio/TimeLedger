# TimeLedger 功能業務邏輯 (Business Logic)

## 1. 個人行程與循環規則 (Personal Recurrence Logic)
針對免費版老師/個人用戶，需支援靈活的行程管理。

### 1.1 資料結構
在 `schedule_rules` 或專屬 `personal_events` 表中，新增循環定義欄位（參考 iCalendar RFC 5545 簡化版）。
- **Recurrence Type**: `NONE` (單次), `DAILY` (日), `WEEKLY` (週), `MONTHLY` (月), `CUSTOM` (自訂)
- **Interval**: 間隔 (例如：每 **2** 週)。
- **ByWeekDays**: 指定星期幾 (例如：`[1, 3]` 代表週一、週三)。
- **EndCondition**:
  - `UNTIL`: 直到某日期。
  - `COUNT`:發生幾次後結束。
  - `NEVER`: 永久 (系統內部可限制生成未來 N 年)。

### 1.2 展開邏輯 (Expansion Logic)
前端即時計算或後端查詢時展開：
1. **讀取 Rule**：取得 `start_at` (首次開始時間) 與 循環參數。
2. **計算 Candidate Dates**：
   - 若 `WEEKLY`, `interval=2`, `days=[Mon, Wed]`。
   - 從 `start_at` 開始，每加 2 週，找出該週的 Mon 與 Wed。
3. **過濾 Exceptions**：
   - 檢查 `schedule_exceptions` 表。
   - 若某候選日期有 `CANCEL` 紀錄，則不顯示該 Session。
   - 若有 `RESCHEDULE`，則隱藏原 Session，並在 `new_start_at` 顯示新 Session。
4. **輸出 Sessions**：將計算後的 Sessions 列表回傳給前端渲染。

### 1.3 國定假日與自動停課 (Holiday Auto-exclusion)
*   **原則**：中心定義的「假日」優先權高於所有週期的「規則」。
*   **展開邏輯修正**：
    1.  在「展開候選日期 (Candidate Dates)」後。
    2.  對每一天執行：`IF candidates.date IN center_holidays THEN MARK_AS_CANCELLED`。
    3.  **無感停課**：系統不需要為每個假日自動生成一筆 `schedule_exceptions` 紀錄，而是在 `Scheduling Engine` 查詢時動態過濾。這能大幅降低資料庫負擔。

---

## 2. LINE Login 身份認證 (Auth Strategy)
**核心策略**: 老師端採 **LINE Native (無密碼)**，後台管理員採 **Email/Password**。

### 2.1 老師端：LIFF Silent Login (極速登入)
為了達成「點開即登入」的流暢體驗，利用 LIFF SDK 取得身分。

1.  **In-App 開啟 (LIFF Browser)**:
    *   老師點擊 LINE 官方帳號 Chat Menu -> 觸發 LIFF URL (`line://app/{liffId}`).
    *   前端 `liff.init()` -> 自動取得 `id_token` (Silent, 無需跳轉/按鈕)。
    *   **Auto Login**: 前端 POST `id_token` 至 `/auth/line/callback` -> 換取 App JWT。
2.  **外部瀏覽器/桌機**:
    *   顯示「LINE 登入」按鈕 -> 掃 QR Code 或輸入 LINE 帳密。
3.  **帳號策略 (Password-less)**:
    *   **完全廢除「設定帳密」功能**。
    *   若老師換手機：安裝 LINE 登入即可。
    *   若 LINE 帳號遺失：聯繫中心管理員，由 Admin 後台重新綁定新的 `line_user_id`。

### 2.2 中心管理員 (Back Office)
- 維持傳統 Email/Password 登入 (因操作人員可能是工讀生，不一定方便用私人 LINE)。
- 支援 JWT Session，Token 效期設定為 24 小時。

---

## 3. 匯出課表圖片邏輯 (Export Image Logic)

### 3.1 挑戰
- 手機螢幕窄，直接截圖 (Screenshot) 只有 3 天，不完整且無法列印。
- 需產生「完整一週」且「版面美觀」的圖片。

### 3.2 實作方案 (Frontend-side Generation)
1. **User** 點擊「匯出圖片」。
2. **Frontend** 準備一個 **Hidden Container (`position: absolute; left: -9999px`)**。
   - 設定容器寬度固定為 `1200px` (適合寬螢幕/列印)。
   - 在容器內 Render 一個「專用匯出 Component」：
     - Header: LOGO、老師姓名、**3-5 個個人品牌標籤 (Personal Tags)**、日期範圍。
     - Body: 完整的週課表 Grid (7 cols)，包含所有課程顏色區塊。
     - Footer: 浮水印或匯出時間。
3. **Wait**: 等待 DOM 渲染完成 (React/Vue `nextTick`)。
4. **Capture**: 呼叫 `html2canvas` 或 `dom-to-image` 針對該 Hidden Container 截圖。
5. **Output**: 取得 Base64 Image Data，觸發瀏覽器下載或 Web Share。

---

## 4. 排課驗證邏輯 (Validation Engine - V3 Core)
所有「中心排課」、「老師改期」、「個人行程」皆需通過此驗證。

### 4.1 驗證層級
1. **Scope Check**: 確保操作都在指定 `center_id` 下 (個人行程除外)。
2. **Hard Overlap Check (硬衝突)**:
   - 查詢目標時段 `[Start, End]` 內，該 `Teacher` 或 `Room` 是否已有其他 `Active Session`。
   - 規則：`Existing.Start < New.End AND Existing.End > New.Start`。
   - **結果**：若 True，直接報錯 `E_OVERLAP` (不可覆寫)。
   - **彈性排課 (Drafting)**：若 `teacher_id` 為空 (NULL)，系統會跳過 Teacher Overlap 檢查，僅驗證 Room。
3. **Buffer Check (緩衝)**:
   - 查詢 前一堂課 `Prev` 與 後一堂課 `Next`。
   - **Room Buffer**: `New.Start - Prev.End < current_course.room_buffer_min` ?
   - **Teacher Buffer**: 若已指派老師，則驗證 `New.Start - Prev.End < current_course.teacher_buffer_min` ? (若無老師則跳過)。
   - **結果**：若 True，報錯 `E_BUFFER`。
     - 檢查該 `offering.allow_buffer_override`。若 False → 阻擋。
     - 若 True → 標記 `conflict`，允許帶 `override=true` 旗標送出 (由管理員決定或進入 Pending)。

### 4.2 狀態變遷 (State Transition)
- **Normal**: Validate Pass → Create `Approved` Session.
- **Buffer Conflict (Admin)**: Validate Fail (Buffer) → Admin Confirm Override → Create `Approved` Session (Audit Log logged).
- **Buffer Conflict (Teacher)**: Validate Fail (Buffer) → Teacher Request → Create `Pending` Exception → Admin Approve → `Approved`.

---

## 5. 多中心資料隔離
- **Table Design**: 所有核心表 (`rules`, `sessions`, `courses`) 必備 `center_id` 欄位。
- **Query Filter**: Backend Middleware 必須從 Token 解析身分。
  - Admin Token: 鎖定特定 `center_id`。
  - Teacher Token: Query 時必須 `WHERE center_id IN (teacher.joined_centers)` 或明確指定單一 `center_id`。
- **個人行程 (Free Only)**:
  - `center_id` 為 `NULL` 或 `0`。
  - **Conflict Strategy (衝突策略)**:
    - **Teacher View**: User 新增個人行程時，若與已存在的 Center Session 重疊，系統顯示 **Warning** (您該時段已有排課)，但不強制禁止 (允許重疊，例如：排入「通勤」或「備課」)。
    - **Center View**: Admin 排課時，若撞到 Teacher 的 Personal Event，系統 API 回傳 **Conflict (Type: PERSONAL)**，但在 UI 上通常呈現為「灰色忙碌時段」，允許 Admin 依政策決定是否要排入 (Admin 權限較高，或視為協商)。
    - **Export View**: 匯出時，若開啟隱私模式，所有 Personal Event 的 Title 自動遮蔽為 "Busy"。

---

## 6. 智慧媒合演算法 (Smart Matching Logic)

### 6.1 目標
在已知 `Center`、`TimeRange` 與 `Skills` 的情況下，排序出最合適的老師清單。

### 6.2 評分因子 (Scoring Factors)
1.  **Availability (權重 40%)**:
    *   完全空閒 (Available): +40分。
    *   Buffer 衝突 (Soft Conflict): +15分 (需 Override)。
    *   Hard Overlap: 0分 (顯示 Disabled)。
2.  **Internal Evaluation (權重 40%) - *核心契合度***:
    *   **星等評分 (Rating)**: 正規化 `center_teacher_notes.rating` (1~5星) 到 0~30分。
    *   **歷史備註 (Notes Insight)**: 系統在媒合清單中提取 `internal_note` 關鍵字，若有正面標籤 (如：#推薦) 額外 +10分。
3.  **Skill & Region Match (權重 20%)**:
    *   技能命中 (Skill Match): +10分。
    *   標籤命中 (Hashtag Match):
        *   技能標籤命中: +8分 (專業度匹配)。
        *   個人品牌標籤命中: +2分 (風格匹配)。
    *   地區命中 (City/District Match): +10分。

### 6.3 查詢優化
*   先篩選 `center_memberships.status = ACTIVE` 的老師。
*   Join `teacher_skills` 過濾技能。
*   對篩選出的候選人，批次執行 `Validation Engine` 檢查時段狀態。

---

## 7. 併發控制與資料安全 (Concurrency & Security)

> [!CAUTION]
> **內評隱私牆 (Security Wall)**：`center_teacher_notes` 及其評分屬於該中心的私有資產。後端 API 必須具備 **Hard Scope Check**，確保 A 中心管理員絕對無法讀取 B 中心對同一位老師的備註，且該內容絕對不可流向老師端。


### 7.1 排課 Race Condition 處理
當多個 Center 同時嘗試對同一位 Teacher 排課時：
1.  **Transaction Start**: 開啟資料庫交易。
2.  **Pessimistic Lock (Row Lock)**: 執行 `SELECT id FROM teachers WHERE id = ? FOR UPDATE`。
    - 這會暫停其他針對該 Teacher 的寫入交易，直到當前交易結束。
3.  **Validation**: 執行 `SELECT ... FROM schedule_sessions` 檢查重疊。
4.  **Insert/Update**: 寫入排課資料。
5.  **Commit**: 釋放鎖定。

### 7.2 證照存取權限 (Certificate ACL)
- **Teacher Owner**: 可 CRUD 自己的證照。
- **Center Admin**:
  - **READ**: 僅能讀取 `center_memberships` 為 `ACTIVE` 的老師證照。
  - **Logic**: API `GET /certificates` 必須 Join `center_memberships` 檢查 `center_id` 與 `teacher_id` 的關聯是否存在且有效。

---

## 8. 異動審核流程與狀態機 (Exception & Approval Workflow)
針對老師提出的「請假 (Cancel)」或「異動 (Reschedule)」申請，必須遵循嚴格的狀態流轉與驗證。

### 8.1 狀態機 (State Machine)
1.  **PENDING (已提交/待審)**:
    *   **觸發**: 老師送出異動申請，且 Policy 設定 `require_approval = true` 或觸發 Buffer 警告。
    *   **行為**: 寫入 `schedule_exceptions`，但不影響 `Active Sessions` (原課程仍視為有效，直到核准)。
2.  **APPROVED (已核准)**:
    *   **觸發**: 管理員點擊「同意」。
    *   **行為**:
        1.  **Lock & Re-validate**: 鎖定 Teacher/Room，再次檢查新時段是否衝突 (避免審核期間被其他人搶走)。
        2.  **Effective**: 狀態變更為 APPROVED，系統正式將原時段釋出 (Cancel) 或 建立新時段 (Reschedule)。
        3.  **Notify**: 發送 LINE 通知給老師「申請已通過」。
3.  **REJECTED (已拒絕)**:
    *   **觸發**: 管理員點擊「拒絕」。
    *   **行為**: 標記為 REJECTED，保留紀錄供查詢。通知老師「申請被拒」。
4.  **REVOKED (已撤回)**:
    *   **觸發**: 老師在管理員審核**前**，自行取消申請。
    *   **行為**: 標記為 REVOKED。

### 8.2 審核防撞機制 (Re-validation on Approval)
*   **情境**: 老師週一申請週五 10:00 改期。管理員週三才審核。這兩天內週五 10:00 可能已被排入其他課程。
*   **規則**: **Approval 視為一次「寫入」操作**。
    *   管理員按下 Approve 的瞬間，系統必須執行 `validate(new_time)`。
    *   若發現衝突 (例如已被代課老師佔用):
        *   **Soft Conflict (Buffer)**: 彈出警告，允許 Admin `Override`。
        *   **Hard Conflict (Overlap)**: **直接報錯 (Error)**，禁止核准。管理員必須先處理佔用該時段的課程，或請老師換時間。

### 4.6 狀態轉換嚴格定義 (State Machine Transition Rules)
| From | To | Trigger | Action |
|:---|:---|:---|:---|
| (None) | **PENDING** | Teacher Submit | Create Record, Validate(Soft) |
| **PENDING** | **REVOKED** | Teacher Cancel | Mark Resolved |
| **PENDING** | **APPROVED** | Admin Approve | **Re-Validate(Hard)**, Apply to Schedule |
| **PENDING** | **REJECTED** | Admin Deny | Mark Resolved, Notify Teacher |
| **APPROVED** | **CANCELLED** | Admin Undo | Revert Schedule (if date not past) |

---

## 5. Hashtag 字典維護邏輯 (Hashtag Management)

為了保持標籤系統的精簡與準確，採取「動態新增、無感清理」策略。

### 5.1 儲存時同步 (Sync on Save)
當老師儲存個人檔案時，針對 **每一項技能** 的標籤：
1. **解析輸入**：前端傳入技能及其對應的標籤陣列 (e.g. `Skill: "街舞", Tags: ["#街舞基礎", "#MV"]`)。
2. **Upsert Dictionary**：
   - 後端檢查 `hashtags` 字典表中是否已存在該標籤。
   - 若不存在：新增至 `hashtags` 表。
3. **更新關聯**：
   - 建立/更新 `teacher_skill_hashtags` 關聯表。
   - **更新 `usage_count`**：重新計算該標籤的全域使用次數 (同一個標籤可被不同技能引用)。

### 5.2 個人品牌標籤限額 (Personal Tag Limit)
對於 **個人品牌標籤 (Teacher Personal Hashtags)**：
1. **獨立同步**：在 Profile 儲存時，由單獨的 `personal_hashtags` 欄位傳入。
2. **長度校驗**：
   - 後端嚴格校驗長度為 3-5。
   - 若不符合，回傳 `E_VALIDATION` 錯誤，確保匯出圖片的版面美感與資訊精簡。

### 5.3 自動清理 (Garbage Collection)
為了避免無人使用的錯誤標籤堆積：
1. **同步清理**：在更新 `usage_count` 後，若偵測到某標籤的 `usage_count == 0`，則立即從 `hashtags` 表中刪除。
2. **排程檢查 (選配)**：每日凌晨掃描一次 `usage_count = 0` 的殘留資料並剔除。
### 5.4 輸入行為 UX 規範 (Behavioral UX)
1. **自動前綴 (Auto-prefix)**：若老師輸入標籤漏掉 `#`，後端/前端自動補上，確保資料一致。
2. **防抖動搜尋 (Debounced Search)**：前端輸入時需延遲 300~500ms 才發送 `/common/hashtags/search` 請求，節省伺服器資源並提供流暢感。
3. **重複檢查**：當老師新增標籤時，若該標籤已存在於現有列表（大小寫不同亦然），則自動忽略，避免重複。

---

## 7. 教室管理與週期分段 (Room & Phase-based Recurrence)

### 7.1 教室管理 (Room Management)
*   **資源綁定**: 教室由 `Center` 擁有，排課時需檢查 `Room` 的容納人數是否符合預期。
*   **教室課表 (Room Schedule View)**:
    *   在後台提供「以教室為橫軸」的視圖。
    *   **查詢邏輯**: `SELECT * FROM schedule_rules WHERE room_id = ? AND overlap(effective_start, effective_end, query_range)`.

### 7.2 週期分段 (Phase-based Recurrence)
*   **場景**: 同一堂課 (Offering) 在不同月份可能有不同的上課時間或教室。
*   **數據模型**: `schedule_rules` 使用 `effective_start` 與 `effective_end` 進行日期段限製。
*   **規則轉換邏輯 (Transition Logic)**:
    1.  **Phase Creation**: 當使用者想要修改三月份之後的週期時，建議「不要修改二月的規則」，而是「新增一條三月開始的規則」。
    2.  **Overlapping Validation**: 系統必須確保同一 `offering_id` 在同一時間點（日期 + 星期 + 時段）僅能有一條有效的 `rule`。
    3.  **Mid-term Room Change**: 若要更換教室，只需新增一條新 Date Range 的規則，指派至新 `room_id` 即可。

### 7.3 衝突預檢 (Validate Engine v2)
*   **衝突檢查矩陣**:
    *   **Time Check**: 檢查「該日期段」內所有「生效」的 Rules。
    *   **Room Check**: `count(sessions_in_room) <= room.capacity` (若為 1 對 1 則檢查 Overlap)。
    *   **Gap Support**: 支持在兩個 Phase 之間留空檔（例如寒暑假停課，只需不建立該區間的 Rule 即可）。

---

## 8. 預約排課與異動截止 (Advance Scheduling & Deadlines)

### 8.1 老師異動窗口 (Teacher Exception Window)
*   **背景**：中心通常提早 1-2 個月排定「預計課表」供內部檢視，此時老師需確認其可用性。
*   **截止邏輯 (Locking Mechanism)**：
    *   **優先序 1 (Explicit Lock)**：若 `schedule_rules.lock_at` 已設定，且當前時間已超過該時間，則老師不可發起請假/改期。
    *   **優先序 2 (Dynamic Lead Time)**：若無顯式設定，則依 `center.exception_lead_days` 計算。若 (課程日期 - 當前日期) < `lead_days`，則視為鎖定。
*   **權限差異**：
    *   **老師 (Teacher)**：鎖定後「請假」與「改期」按鈕變灰（Disabled），顯示「已超過異動截止日」。
    *   **中心管理員 (Admin)**：**完全不受限**。管理員可隨時透過後台進行強行調整、異動或替換老師。

### 8.2 下期課程預排流程
1.  **Phase Creation**：管理員設定 5-6 月的高級規則，並設定 `lock_at` 為 4/15。
2.  **Teacher Review**：老師在 2-4 月間可自由對 5-6 月課程提出異動。
3.  **Finalization**：4/16 之後，老師端按鈕鎖定，確保排課穩定性。

---

## 9. 緩衝時間疊加計算邏輯 (Buffer Calculation Logic)

### 9.1 緩衝時間來源
排課緩衝時間可能來自以下來源，系統需正確疊加：

| 來源 | 欄位 | 說明 |
|:---|:---|:---|
| 課程模板 (Course) | `room_buffer_min` | 該課程所需的教室清潔時間 |
| 課程模板 (Course) | `teacher_buffer_min` | 該課程所需的老師轉場時間 |
| 老師設定 (Teacher) | `default_buffer_min` | 老師個人的預設轉場時間（選配） |
| 教室設定 (Room) | `cleaning_time` | 教室固定清潔時間（選配） |

### 9.2 緩衝時間疊加公式
系統計算時，採用「取最大值」而非「相加」的策略：

**教室緩衝時間 (Room Buffer)**:
```
RoomBuffer = max(
  CourseA.room_buffer_min,
  CourseB.room_buffer_min,
  Room.cleaning_time
)
```

**老師緩衝時間 (Teacher Buffer)**:
```
TeacherBuffer = max(
  CourseA.teacher_buffer_min,
  CourseB.teacher_buffer_min,
  Teacher.default_buffer_min
)
```

### 9.3 緩衝時間驗證流程
1. 取得前一堂課 `Prev` 與後一堂課 `Next`。
2. 計算 `ActualGap = Next.Start - Prev.End`。
3. 計算所需緩衝 `RequiredBuffer = max(Prev.teacher_buffer_min, Next.teacher_buffer_min)`。
4. 驗證 `ActualGap >= RequiredBuffer`。
5. 若不足，報錯 `E_SCHED_BUFFER`，並在 Response 中標註所需緩衝時間。

### 9.4 緩衝衝突回應格式
當發生 Buffer 衝突時，Validate API 回傳：
```json
{
  "valid": false,
  "conflicts": [
    {
      "type": "TEACHER_BUFFER",
      "message": "老師上一堂課（13:00結束）與本堂課（13:05開始）間隔不足",
      "current_gap_minutes": 5,
      "required_buffer_minutes": 15,
      "previous_session": {
        "id": 123,
        "course_name": "瑜伽基礎",
        "end_at": "2026-01-20T13:00:00"
      },
      "can_override": true,
      "override_policy": "Offering allows buffer override"
    }
  ]
}
```

---

## 10. 課程複製邏輯 (Course Copy Logic)

### 10.1 �發場景
管理員在排課 Grid 上選擇某個班別 (Offering) 的規則，右鍵選擇「複製」，或點擊班別詳情頁的「複製班別」按鈕。

### 10.2 複製行為對照表
| 欄位 | 複製行為 | 說明 |
|:---|:---|:---|
| `offering_id` | **新建立** | 全新班別，產生新的 offering_id |
| `course_id` | **複製** | 關聯同一個課程模板 |
| `name` | **可選覆寫** | 預設加上「(複製)」後綴 |
| `teacher_id` | **可選** | 可選擇是否複製原老師，或留空 |
| `room_id` | **複製** | |
| `weekday` | **複製** | |
| `start_time` / `end_time` | **複製** | |
| `effective_start` | **必填覆寫** | 管理員需指定新日期範圍 |
| `effective_end` | **必填覆寫** | 管理員需指定新結束日期 |
| `lock_at` | **預設值** | 依中心政策，不複製原設定 |
| `allow_buffer_override` | **複製** | |
| `schedule_rules` | **可選** | 可選擇是否複製關聯的排課規則 |

### 10.3 複製後操作
1. 複製完成後，系統自動導向「編輯新班別」頁面。
2. 管理員需調整：
   - 新班別名稱（預設加上序號或日期）
   - 生效日期範圍（必填）
   - 老師指派（可選）
3. 若選擇複製規則，系統會自動為新班別建立對應的 `schedule_rules`。

### 10.4 複製 API 行為
```go
// POST /admin/centers/{id}/offerings/{offering_id}/copy
func (s *OfferingService) Copy(ctx context.Context, req *CopyOfferingRequest) (*CopyOfferingResponse, error) {
  // 1. 取得原始 offering
  original, _ := s.Get(offering_id)

  // 2. 建立新的 offering
  newOffering := &models.Offering{
    CenterID: original.CenterID,
    CourseID: original.CourseID,
    Name: req.NewName,
    DefaultRoomID: original.DefaultRoomID,
    AllowBufferOverride: original.AllowBufferOverride,
  }
  s.repo.Create(newOffering)

  // 3. 若有複製規則
  if req.CopyRules {
    originalRules := s.ruleRepo.ListByOffering(original.ID)
    for _, rule := range originalRules {
      newRule := &models.ScheduleRule{
        CenterID: rule.CenterID,
        OfferingID: newOffering.ID,
        TeacherID: req.CopyTeacher ? rule.TeacherID : nil,
        RoomID: rule.RoomID,
        Weekday: rule.Weekday,
        StartTime: rule.StartTime,
        EndTime: rule.EndTime,
        EffectiveStart: req.EffectiveStart,
        EffectiveEnd: req.EffectiveEnd,
      }
      s.ruleRepo.Create(newRule)
    }
  }

  return &CopyOfferingResponse{
    ID: newOffering.ID,
    Name: newOffering.Name,
    RulesCopied: len(originalRules),
  }, nil
}
```

### 10.5 複製後的例外處理
- 原始班別的 `schedule_exceptions` **不會** 複製到新班別。
- 新班別從 `effective_start` 開始，不繼承歷史例外。
